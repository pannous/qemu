<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Gradient Cube - Performance Baseline</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #000;
            color: #fff;
            font-family: monospace;
            overflow: hidden;
        }
        canvas {
            display: block;
            margin: 20px auto;
            border: 1px solid #333;
        }
        #fps {
            position: fixed;
            top: 10px;
            left: 10px;
            font-size: 16px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 4px;
        }
        #info {
            text-align: center;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div id="info">WebGL Gradient Cube - Browser Performance Baseline</div>
    <canvas id="glCanvas" width="800" height="600"></canvas>
    <div id="fps">FPS: 0</div>

    <script>
        // Vertex shader
        const vsSource = `
            attribute vec3 aPosition;
            attribute vec3 aColor;

            uniform mat4 uModelViewProjection;

            varying vec3 vColor;

            void main() {
                gl_Position = uModelViewProjection * vec4(aPosition, 1.0);
                vColor = aColor;
            }
        `;

        // Fragment shader
        const fsSource = `
            precision mediump float;
            varying vec3 vColor;

            void main() {
                gl_FragColor = vec4(vColor, 1.0);
            }
        `;

        // Cube vertices: position (x,y,z) + color (r,g,b)
        const cubeVertices = new Float32Array([
            // Front face
            -1, -1,  1,  1, 0, 0,    1, -1,  1,  0, 1, 0,    1,  1,  1,  0, 0, 1,   -1,  1,  1,  1, 1, 0,
            // Back face
             1, -1, -1,  0, 1, 1,   -1, -1, -1,  1, 0, 1,   -1,  1, -1,  1, 1, 1,    1,  1, -1,  0.5, 0.5, 0.5,
            // Left face
            -1, -1, -1,  1, 0, 1,   -1, -1,  1,  1, 0, 0,   -1,  1,  1,  1, 1, 0,   -1,  1, -1,  1, 1, 1,
            // Right face
             1, -1,  1,  0, 1, 0,    1, -1, -1,  0, 1, 1,    1,  1, -1,  0.5, 0.5, 0.5,    1,  1,  1,  0, 0, 1,
            // Top face
            -1,  1,  1,  1, 1, 0,    1,  1,  1,  0, 0, 1,    1,  1, -1,  0.5, 0.5, 0.5,   -1,  1, -1,  1, 1, 1,
            // Bottom face
            -1, -1, -1,  1, 0, 1,    1, -1, -1,  0, 1, 1,    1, -1,  1,  0, 1, 0,   -1, -1,  1,  1, 0, 0,
        ]);

        const cubeIndices = new Uint16Array([
             0,  1,  2,   2,  3,  0,  // Front
             4,  5,  6,   6,  7,  4,  // Back
             8,  9, 10,  10, 11,  8,  // Left
            12, 13, 14,  14, 15, 12,  // Right
            16, 17, 18,  18, 19, 16,  // Top
            20, 21, 22,  22, 23, 20,  // Bottom
        ]);

        // Matrix operations
        function perspective(fovy, aspect, near, far) {
            const f = 1.0 / Math.tan(fovy / 2);
            const nf = 1 / (near - far);
            return new Float32Array([
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (far + near) * nf, -1,
                0, 0, 2 * far * near * nf, 0
            ]);
        }

        function multiply(a, b) {
            const result = new Float32Array(16);
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    result[i * 4 + j] =
                        a[i * 4 + 0] * b[0 * 4 + j] +
                        a[i * 4 + 1] * b[1 * 4 + j] +
                        a[i * 4 + 2] * b[2 * 4 + j] +
                        a[i * 4 + 3] * b[3 * 4 + j];
                }
            }
            return result;
        }

        function rotationMatrix(angle) {
            const rotY = Math.cos(angle);
            const rotYsin = Math.sin(angle);
            const rotX = Math.cos(angle * 0.7);
            const rotXsin = Math.sin(angle * 0.7);

            return new Float32Array([
                rotY, 0, rotYsin, 0,
                rotYsin * rotXsin, rotX, -rotY * rotXsin, 0,
                -rotYsin * rotX, rotXsin, rotY * rotX, 0,
                0, 0, -5, 1
            ]);
        }

        // Initialize WebGL
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl', {
            antialias: false,
            depth: true,
            alpha: false,
            preserveDrawingBuffer: false
        });

        if (!gl) {
            alert('WebGL not supported');
            throw new Error('WebGL not supported');
        }

        // Compile shader
        function compileShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Create program
        const vertexShader = compileShader(gl.VERTEX_SHADER, vsSource);
        const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fsSource);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program link error:', gl.getProgramInfoLog(program));
            throw new Error('Program link failed');
        }

        // Get attribute and uniform locations
        const positionLoc = gl.getAttribLocation(program, 'aPosition');
        const colorLoc = gl.getAttribLocation(program, 'aColor');
        const mvpLoc = gl.getUniformLocation(program, 'uModelViewProjection');

        // Create buffers
        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, cubeVertices, gl.STATIC_DRAW);

        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cubeIndices, gl.STATIC_DRAW);

        // Enable depth test
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LESS);
        gl.enable(gl.CULL_FACE);
        gl.cullFace(gl.BACK);

        // FPS counter
        let frameCount = 0;
        let totalFrames = 0;
        let lastTime = performance.now();
        let startTime = lastTime;
        let rotation = 0;

        function render() {
            const now = performance.now();
            frameCount++;
            totalFrames++;

            // Update FPS every second
            if (now - lastTime >= 1000) {
                const instantFPS = frameCount / ((now - lastTime) / 1000);
                const avgFPS = totalFrames / ((now - startTime) / 1000);
                document.getElementById('fps').textContent =
                    `FPS: ${instantFPS.toFixed(1)} (avg: ${avgFPS.toFixed(1)} over ${totalFrames} frames)`;
                frameCount = 0;
                lastTime = now;
            }

            rotation += 0.01;

            // Clear
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // Calculate MVP matrix
            const aspect = canvas.width / canvas.height;
            const projection = perspective(Math.PI / 4, aspect, 0.1, 100.0);
            const model = rotationMatrix(rotation);
            const mvp = multiply(projection, model);

            // Use program
            gl.useProgram(program);

            // Bind vertex buffer and set attributes
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);

            const stride = 6 * 4; // 6 floats per vertex
            gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, stride, 0);
            gl.enableVertexAttribArray(positionLoc);

            gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, stride, 3 * 4);
            gl.enableVertexAttribArray(colorLoc);

            // Set uniform
            gl.uniformMatrix4fv(mvpLoc, false, mvp);

            // Draw
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.drawElements(gl.TRIANGLES, cubeIndices.length, gl.UNSIGNED_SHORT, 0);

            requestAnimationFrame(render);
        }

        console.log('WebGL Gradient Cube - Browser Performance Baseline');
        console.log('GPU:', gl.getParameter(gl.RENDERER));
        console.log('Vendor:', gl.getParameter(gl.VENDOR));

        // Start rendering
        requestAnimationFrame(render);
    </script>
</body>
</html>
