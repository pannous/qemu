<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Gradient Cube - Performance Baseline</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #000;
            color: #fff;
            font-family: monospace;
            overflow: hidden;
        }
        canvas {
            display: block;
            margin: 20px auto;
            border: 1px solid #333;
        }
        #fps {
            position: fixed;
            top: 10px;
            left: 10px;
            font-size: 16px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 4px;
        }
        #info {
            text-align: center;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div id="info">WebGL Gradient Cube - Browser Performance Baseline</div>
    <canvas id="glCanvas" width="800" height="600"></canvas>
    <div id="fps">FPS: 0</div>

    <script>
        // Vertex shader
        const vsSource = `
            attribute vec3 aPosition;
            attribute vec3 aColor;

            uniform mat4 uModelViewProjection;

            varying vec3 vColor;

            void main() {
                gl_Position = uModelViewProjection * vec4(aPosition, 1.0);
                vColor = aColor;
            }
        `;

        // Fragment shader
        const fsSource = `
            precision mediump float;
            varying vec3 vColor;

            void main() {
                gl_FragColor = vec4(vColor, 1.0);
            }
        `;

        // Cube vertices: position (x,y,z) + color (r,g,b)
        const cubeVertices = new Float32Array([
            // Front face
            -1, -1,  1,  1, 0, 0,    1, -1,  1,  0, 1, 0,    1,  1,  1,  0, 0, 1,   -1,  1,  1,  1, 1, 0,
            // Back face
             1, -1, -1,  0, 1, 1,   -1, -1, -1,  1, 0, 1,   -1,  1, -1,  1, 1, 1,    1,  1, -1,  0.5, 0.5, 0.5,
            // Left face
            -1, -1, -1,  1, 0, 1,   -1, -1,  1,  1, 0, 0,   -1,  1,  1,  1, 1, 0,   -1,  1, -1,  1, 1, 1,
            // Right face
             1, -1,  1,  0, 1, 0,    1, -1, -1,  0, 1, 1,    1,  1, -1,  0.5, 0.5, 0.5,    1,  1,  1,  0, 0, 1,
            // Top face
            -1,  1,  1,  1, 1, 0,    1,  1,  1,  0, 0, 1,    1,  1, -1,  0.5, 0.5, 0.5,   -1,  1, -1,  1, 1, 1,
            // Bottom face
            -1, -1, -1,  1, 0, 1,    1, -1, -1,  0, 1, 1,    1, -1,  1,  0, 1, 0,   -1, -1,  1,  1, 0, 0,
        ]);

        const cubeIndices = new Uint16Array([
             0,  1,  2,   2,  3,  0,  // Front
             4,  5,  6,   6,  7,  4,  // Back
             8,  9, 10,  10, 11,  8,  // Left
            12, 13, 14,  14, 15, 12,  // Right
            16, 17, 18,  18, 19, 16,  // Top
            20, 21, 22,  22, 23, 20,  // Bottom
        ]);

        // Matrix operations - proper column-major for WebGL
        function perspective(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            const rangeInv = 1.0 / (near - far);

            // Column-major perspective matrix
            return new Float32Array([
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (near + far) * rangeInv, -1,
                0, 0, near * far * rangeInv * 2, 0
            ]);
        }

        function translate(x, y, z) {
            return new Float32Array([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                x, y, z, 1
            ]);
        }

        function rotateX(angle) {
            const c = Math.cos(angle);
            const s = Math.sin(angle);
            return new Float32Array([
                1, 0, 0, 0,
                0, c, s, 0,
                0, -s, c, 0,
                0, 0, 0, 1
            ]);
        }

        function rotateY(angle) {
            const c = Math.cos(angle);
            const s = Math.sin(angle);
            return new Float32Array([
                c, 0, -s, 0,
                0, 1, 0, 0,
                s, 0, c, 0,
                0, 0, 0, 1
            ]);
        }

        function multiply(a, b) {
            const result = new Float32Array(16);
            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    result[col * 4 + row] =
                        a[0 * 4 + row] * b[col * 4 + 0] +
                        a[1 * 4 + row] * b[col * 4 + 1] +
                        a[2 * 4 + row] * b[col * 4 + 2] +
                        a[3 * 4 + row] * b[col * 4 + 3];
                }
            }
            return result;
        }

        // Initialize WebGL
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl', {
            antialias: false,
            depth: true,
            alpha: false,
            preserveDrawingBuffer: false
        });

        if (!gl) {
            alert('WebGL not supported');
            throw new Error('WebGL not supported');
        }

        // Compile shader
        function compileShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Create program
        const vertexShader = compileShader(gl.VERTEX_SHADER, vsSource);
        const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fsSource);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program link error:', gl.getProgramInfoLog(program));
            throw new Error('Program link failed');
        }

        // Get attribute and uniform locations
        const positionLoc = gl.getAttribLocation(program, 'aPosition');
        const colorLoc = gl.getAttribLocation(program, 'aColor');
        const mvpLoc = gl.getUniformLocation(program, 'uModelViewProjection');

        // Create buffers
        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, cubeVertices, gl.STATIC_DRAW);

        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cubeIndices, gl.STATIC_DRAW);

        // Enable depth test
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LESS);
        gl.enable(gl.CULL_FACE);
        gl.cullFace(gl.BACK);

        // FPS counter and frame timing
        let frameCount = 0;
        let totalFrames = 0;
        let lastTime = performance.now();
        let startTime = lastTime;
        let rotation = 0;
        let firstFrame = true;
        let frameTimesSum = 0;
        let lastFrameTime = performance.now();

        function render() {
            if (firstFrame) {
                console.log('First frame rendering...');
                firstFrame = false;
            }

            const now = performance.now();
            const frameTime = now - lastFrameTime;
            lastFrameTime = now;

            frameCount++;
            totalFrames++;
            frameTimesSum += frameTime;

            // Update FPS every second
            if (now - lastTime >= 1000) {
                const instantFPS = frameCount / ((now - lastTime) / 1000);
                const avgFPS = totalFrames / ((now - startTime) / 1000);
                const avgFrameTime = frameTimesSum / frameCount;
                document.getElementById('fps').textContent =
                    `FPS: ${instantFPS.toFixed(1)} (avg: ${avgFPS.toFixed(1)}) | Frame time: ${avgFrameTime.toFixed(2)}ms (${(1000/avgFrameTime).toFixed(1)} max FPS)`;
                frameCount = 0;
                frameTimesSum = 0;
                lastTime = now;
            }

            rotation += 0.01;

            // Clear
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // Calculate MVP matrix
            const aspect = canvas.width / canvas.height;
            const projection = perspective(Math.PI / 4, aspect, 0.1, 100.0);

            // Model matrix: rotate around Y and X axes
            let model = rotateY(rotation);
            model = multiply(model, rotateX(rotation * 0.7));

            // View matrix: translate back so we can see the cube
            const view = translate(0, 0, -5);

            // Combine: projection * view * model
            let mvp = multiply(view, model);
            mvp = multiply(projection, mvp);

            // Use program
            gl.useProgram(program);

            // Bind vertex buffer and set attributes
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);

            const stride = 6 * 4; // 6 floats per vertex
            gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, stride, 0);
            gl.enableVertexAttribArray(positionLoc);

            gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, stride, 3 * 4);
            gl.enableVertexAttribArray(colorLoc);

            // Set uniform
            gl.uniformMatrix4fv(mvpLoc, false, mvp);

            // Draw
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.drawElements(gl.TRIANGLES, cubeIndices.length, gl.UNSIGNED_SHORT, 0);

            requestAnimationFrame(render);
        }

        console.log('WebGL Gradient Cube - Browser Performance Baseline');
        console.log('GPU:', gl.getParameter(gl.RENDERER));
        console.log('Vendor:', gl.getParameter(gl.VENDOR));
        console.log('Max Texture Size:', gl.getParameter(gl.MAX_TEXTURE_SIZE));
        console.log('Viewport:', canvas.width, 'x', canvas.height);

        // Start rendering
        requestAnimationFrame(render);
    </script>
</body>
</html>
