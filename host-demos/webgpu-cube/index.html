<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>WebGPU Rotating Gradient Cube</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #1a1a2e;
            font-family: monospace;
            color: #eee;
        }
        canvas {
            border: 2px solid #0f3460;
            box-shadow: 0 0 20px rgba(15, 52, 96, 0.5);
        }
        #info {
            margin-top: 20px;
            font-size: 18px;
            text-align: center;
        }
        #fps {
            color: #16c79a;
            font-weight: bold;
            font-size: 24px;
        }
        #error {
            color: #ff6b6b;
            max-width: 600px;
            padding: 20px;
            background: rgba(255, 107, 107, 0.1);
            border-radius: 8px;
            margin: 20px;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="800" height="600"></canvas>
    <div id="info">
        <div>WebGPU Rotating Gradient Cube - Performance Baseline</div>
        <div id="fps">FPS: 0</div>
    </div>
    <div id="error" style="display: none;"></div>

    <script type="module">
        // Check WebGPU support
        if (!navigator.gpu) {
            document.getElementById('error').style.display = 'block';
            document.getElementById('error').textContent =
                'WebGPU is not supported in this browser. Try Chrome/Edge 113+ or Safari 18+';
            throw new Error('WebGPU not supported');
        }

        const canvas = document.getElementById('canvas');
        const adapter = await navigator.gpu.requestAdapter();
        if (!adapter) {
            throw new Error('No GPU adapter found');
        }
        const device = await adapter.requestDevice();
        const context = canvas.getContext('webgpu');
        const format = navigator.gpu.getPreferredCanvasFormat();
        context.configure({
            device,
            format,
            alphaMode: 'opaque',
        });

        // Cube vertices: position (xyz) + color (rgb)
        const vertices = new Float32Array([
            // Front face
            -1,-1, 1,  1,0,0,   1,-1, 1,  1,1,0,   1, 1, 1,  0,1,0,
            -1,-1, 1,  1,0,0,   1, 1, 1,  0,1,0,  -1, 1, 1,  1,0,1,
            // Back face
             1,-1,-1,  0,1,1,  -1,-1,-1,  1,0.5,0,  -1, 1,-1,  1,0,0,
             1,-1,-1,  0,1,1,  -1, 1,-1,  1,0,0,   1, 1,-1,  0,0,1,
            // Top face
            -1, 1, 1,  0,0,1,   1, 1, 1,  1,1,0,   1, 1,-1,  1,0,1,
            -1, 1, 1,  0,0,1,   1, 1,-1,  1,0,1,  -1, 1,-1,  0,1,0,
            // Bottom face
            -1,-1,-1,  1,0,1,   1,-1,-1,  0,1,1,   1,-1, 1,  1,1,0,
            -1,-1,-1,  1,0,1,   1,-1, 1,  1,1,0,  -1,-1, 1,  0,1,0,
            // Right face
             1,-1, 1,  0,1,0,   1,-1,-1,  1,0,0,   1, 1,-1,  0,0,1,
             1,-1, 1,  0,1,0,   1, 1,-1,  0,0,1,   1, 1, 1,  1,1,0,
            // Left face
            -1,-1,-1,  0,0,0,  -1,-1, 1,  1,0,0,  -1, 1, 1,  1,1,1,
            -1,-1,-1,  0,0,0,  -1, 1, 1,  1,1,1,  -1, 1,-1,  0,0,1,
        ]);

        const vertexBuffer = device.createBuffer({
            size: vertices.byteLength,
            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        });
        device.queue.writeBuffer(vertexBuffer, 0, vertices);

        // Uniform buffer for MVP matrix
        const uniformBuffer = device.createBuffer({
            size: 64, // 4x4 matrix = 16 floats
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });

        // Shader code
        const shaderCode = `
            struct Uniforms {
                mvp: mat4x4<f32>,
            }
            @group(0) @binding(0) var<uniform> uniforms: Uniforms;

            struct VertexInput {
                @location(0) position: vec3<f32>,
                @location(1) color: vec3<f32>,
            }

            struct VertexOutput {
                @builtin(position) position: vec4<f32>,
                @location(0) color: vec3<f32>,
            }

            @vertex
            fn vs_main(in: VertexInput) -> VertexOutput {
                var out: VertexOutput;
                out.position = uniforms.mvp * vec4<f32>(in.position, 1.0);
                out.color = in.color;
                return out;
            }

            @fragment
            fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
                return vec4<f32>(in.color, 1.0);
            }
        `;

        const shaderModule = device.createShaderModule({ code: shaderCode });

        const pipeline = device.createRenderPipeline({
            layout: 'auto',
            vertex: {
                module: shaderModule,
                entryPoint: 'vs_main',
                buffers: [{
                    arrayStride: 24, // 6 floats * 4 bytes
                    attributes: [
                        { shaderLocation: 0, offset: 0, format: 'float32x3' },
                        { shaderLocation: 1, offset: 12, format: 'float32x3' },
                    ],
                }],
            },
            fragment: {
                module: shaderModule,
                entryPoint: 'fs_main',
                targets: [{ format }],
            },
            primitive: {
                topology: 'triangle-list',
                cullMode: 'back',
            },
            depthStencil: {
                depthWriteEnabled: true,
                depthCompare: 'less',
                format: 'depth24plus',
            },
        });

        const depthTexture = device.createTexture({
            size: [canvas.width, canvas.height],
            format: 'depth24plus',
            usage: GPUTextureUsage.RENDER_ATTACHMENT,
        });

        const bindGroup = device.createBindGroup({
            layout: pipeline.getBindGroupLayout(0),
            entries: [{
                binding: 0,
                resource: { buffer: uniformBuffer },
            }],
        });

        // Matrix math
        function mat4Identity() {
            return new Float32Array([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1,
            ]);
        }

        function mat4Perspective(fovy, aspect, near, far) {
            const f = 1.0 / Math.tan(fovy / 2);
            const nf = 1 / (near - far);
            return new Float32Array([
                f / aspect, 0, 0, 0,
                0, -f, 0, 0,
                0, 0, far * nf, -1,
                0, 0, far * near * nf, 0,
            ]);
        }

        function mat4LookAt(eye, center, up) {
            const fx = center[0] - eye[0], fy = center[1] - eye[1], fz = center[2] - eye[2];
            const fl = Math.sqrt(fx*fx + fy*fy + fz*fz);
            const f = [fx/fl, fy/fl, fz/fl];

            const sx = f[1]*up[2] - f[2]*up[1];
            const sy = f[2]*up[0] - f[0]*up[2];
            const sz = f[0]*up[1] - f[1]*up[0];
            const sl = Math.sqrt(sx*sx + sy*sy + sz*sz);
            const s = [sx/sl, sy/sl, sz/sl];

            const u = [s[1]*f[2] - s[2]*f[1], s[2]*f[0] - s[0]*f[2], s[0]*f[1] - s[1]*f[0]];

            return new Float32Array([
                s[0], u[0], -f[0], 0,
                s[1], u[1], -f[1], 0,
                s[2], u[2], -f[2], 0,
                -(s[0]*eye[0] + s[1]*eye[1] + s[2]*eye[2]),
                -(u[0]*eye[0] + u[1]*eye[1] + u[2]*eye[2]),
                f[0]*eye[0] + f[1]*eye[1] + f[2]*eye[2],
                1,
            ]);
        }

        function mat4RotateY(angle) {
            const c = Math.cos(angle), s = Math.sin(angle);
            return new Float32Array([
                c, 0, s, 0,
                0, 1, 0, 0,
                -s, 0, c, 0,
                0, 0, 0, 1,
            ]);
        }

        function mat4RotateX(angle) {
            const c = Math.cos(angle), s = Math.sin(angle);
            return new Float32Array([
                1, 0, 0, 0,
                0, c, -s, 0,
                0, s, c, 0,
                0, 0, 0, 1,
            ]);
        }

        function mat4Multiply(a, b) {
            const out = new Float32Array(16);
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    out[i*4 + j] =
                        a[0*4 + j] * b[i*4 + 0] +
                        a[1*4 + j] * b[i*4 + 1] +
                        a[2*4 + j] * b[i*4 + 2] +
                        a[3*4 + j] * b[i*4 + 3];
                }
            }
            return out;
        }

        // FPS counter
        let frameCount = 0;
        let lastTime = performance.now();
        const fpsElement = document.getElementById('fps');

        function updateFPS() {
            frameCount++;
            const now = performance.now();
            if (now - lastTime >= 1000) {
                fpsElement.textContent = `FPS: ${frameCount}`;
                frameCount = 0;
                lastTime = now;
            }
        }

        // Render loop
        function render(time) {
            time *= 0.001; // Convert to seconds

            // Update MVP matrix
            const model = mat4Multiply(
                mat4RotateY(time * 0.5),
                mat4RotateX(time * 0.7)
            );
            const view = mat4LookAt([0, 0, 5], [0, 0, 0], [0, 1, 0]);
            const proj = mat4Perspective(0.8, canvas.width / canvas.height, 0.1, 100);
            const mvp = mat4Multiply(proj, mat4Multiply(view, model));

            device.queue.writeBuffer(uniformBuffer, 0, mvp);

            const commandEncoder = device.createCommandEncoder();
            const textureView = context.getCurrentTexture().createView();

            const renderPass = commandEncoder.beginRenderPass({
                colorAttachments: [{
                    view: textureView,
                    clearValue: { r: 0.1, g: 0.1, b: 0.15, a: 1.0 },
                    loadOp: 'clear',
                    storeOp: 'store',
                }],
                depthStencilAttachment: {
                    view: depthTexture.createView(),
                    depthClearValue: 1.0,
                    depthLoadOp: 'clear',
                    depthStoreOp: 'store',
                },
            });

            renderPass.setPipeline(pipeline);
            renderPass.setVertexBuffer(0, vertexBuffer);
            renderPass.setBindGroup(0, bindGroup);
            renderPass.draw(36, 1, 0, 0);
            renderPass.end();

            device.queue.submit([commandEncoder.finish()]);

            updateFPS();
            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);
    </script>
</body>
</html>
